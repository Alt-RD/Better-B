%  This file is part of project HiveModel.
%  This work was supported by the Better-B project, which has received funding
%  from the European Union, the Swiss State Secretariat for Education, Research
%  and Innovation (SERI) and UK Research and Innovation (UKRI) under the UK
%  government's Horizon Europe funding guarantee (grant number 10068544). Views
%  and opinions expressed are however those of the author(s) only and do not
%  necessarily reflect those of the European Union, European Research Executive
%  Agency (REA), SERI or UKRI. Neither the European Union nor the granting
%  authorities can be held responsible for them.
%
%  Copyright (c) 2022: Montpellier University
%  Copyright (c) 2023-2025: CoActions-AltRD-Emmanuel Ruffio
%  Author: emmanuel.ruffio@alt-rd.com
%
%  HiveTemp is free software: you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation, either version 3 of the License, or
%  any later version.
%
%  HiveTemp is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with HiveTemp.  If not, see <https://www.gnu.org/licenses/>
% ========================================================================

% ========================================================================
%                            HIVE THERMAL MODEL
% ========================================================================

% Create the figure(1) that will contain the geometry
if lPlotOptions.plotGeometry
  if lPlotOptions.onlyOneFigure, figure(1); clf; subplot(1,1,1); ...
  else figure(1); clf; endif
  set(gca, 'FontSize', 14);
  xlabel('X', 'fontsize', 16, 'fontweight', 'bold');
  ylabel('Y', 'fontsize', 16, 'fontweight', 'bold');
  zlabel('Z', 'fontsize', 16, 'fontweight', 'bold');
  axis equal;
endif

% Create model main object with name "main"
lModel = HT_Model_Init('', 'main');

% Create the node corresponding to the outside air
% It will be connected to face when necessary along the model building process
lAirExtNode = HT_Node_Init('nAirExt', 'mode', 'distributed');

% ========================================================================
% Build air cylinder part
% ========================================================================

[lMod_AirCylinder, lMod_AirCylinderFaces] = HT_Model_ConductionCylinder3D("mAirHB", ...
                                          struct( "radius", [0, lHiveParams.bodyRadius], ...
                                                  "length", lHiveParams.bodyHeight - lHiveParams.overframeThickness - lHiveParams.underroofThickness, ...
                                                  "material", lHiveMat.internalAir, ...
                                                  "n", [lMesh.innerRadius, lMesh.circular, lMesh.bodyAirHeight], ...
                                                  "rGrid", [], ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition, ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_AirCylinder, lOptions);

% ========================================================================
% Build overframe wood layer
% ========================================================================
[lMod_Overframe, lMod_OverframeFaces] = HT_Model_ConductionCylinder3D("mOvf", ...
                                          struct( "radius", [0, lHiveParams.bodyRadius], ...
                                                  "length", lHiveParams.overframeThickness, ...
                                                  "material", lHiveMat.overframe, ...
                                                  "n", [lMesh.innerRadius, lMesh.circular, lMesh.overframe], ...
                                                  "rGrid", [], ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'hh', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition + (lHiveParams.bodyHeight - lHiveParams.overframeThickness - lHiveParams.underroofThickness) * lHiveParams.globalAxis(:,Z) , ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_Overframe, lOptions);

% Connect the internal air cylinder to the overframe
lMod_Tmp = HT_Model_ConnectFaces('mcAir_Ovf',               ...
                                lMod_OverframeFaces.bottom,   ... % Node of outside air
                                lMod_AirCylinderFaces.top,       ... % Top face of the roof
                                struct( 'g', lConvection.ovf_bot), ... % Convection coefficient specified by user
                                lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);



% ========================================================================
% Build underroof air layer
% ========================================================================

[lMod_AirUnderRoof, lMod_AirUnderRoofFaces] = HT_Model_ConductionCylinder3D("mAirUnder", ...
                                          struct( "radius", [0, lHiveParams.bodyRadius], ...
                                                  "length", lHiveParams.underroofThickness, ...
                                                  "material", lHiveMat.internalAir, ...
                                                  "n", [lMesh.innerRadius, lMesh.circular, lMesh.underroof], ...
                                                  "rGrid", [], ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition + (lHiveParams.bodyHeight - lHiveParams.underroofThickness) * lHiveParams.globalAxis(:,Z), ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_AirUnderRoof, lOptions);

% Connect the underroof air layer to the overframe top side
lMod_Tmp = HT_Model_ConnectFaces('mcOvf_Under',            ...
                                lMod_AirUnderRoofFaces.bottom,        ... % Node of outside air
                                lMod_OverframeFaces.top,              ... % Top face of the roof
                                struct( 'g', lConvection.ovf_top),    ... % Convection coefficient specified by user
                                lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);



% ========================================================================
% Build cylinder part
% ========================================================================
[lMod_Cylinder, lMod_CylinderFaces] = HT_Model_ConductionCylinder3D("mHB", ...
                                          struct( "radius", lHiveParams.bodyRadius+[0, lHiveParams.wallThickness], ...
                                                  "length", lHiveParams.bodyHeight, ...
                                                  "material", lHiveMat.walls, ...
                                                  "n", [lMesh.bodyRadius, lMesh.circular, lMesh.bodyHeight], ...
                                                  "rGrid", [], ... 1/(lMesh.bodyRadius-1)*[0.5 ones(1,lMesh.bodyRadius-2) 0.5], ...(0:lMesh.bodyRadius)'/lMesh.bodyRadius, ...
                                                  "rGridType", 'hh', ...
                                                  "zGrid", [lMod_AirCylinderFaces.outside; lMod_AirUnderRoofFaces.outside; lMod_OverframeFaces.outside], ...
                                                  "zGridType", 'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition, ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_Cylinder, lOptions);

% Add external air convection coefficient to the sides
lMod_Tmp = HT_Model_Connect('mSide_ExtAir', lAirExtNode,        ... % Node of outside air
                                  lMod_CylinderFaces.outside,        ... % Top face of the roof
                                  'g', lConvection.walls_ext,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Connect the external wall to the differents volumes inside
assert(numel(lMod_CylinderFaces.outside) == numel(lMod_CylinderFaces.inside));

for i=1:numel(lMod_CylinderFaces.outside)
  lMod_Tmp = HT_Model_ConnectFaces(sprintf('mcWall_IntAir%d', i),     ...
                                  lMod_CylinderFaces.inside(i),       ... % Internal faces of the wall
                                  lMod_AirCylinderFaces.outside(i),   ... % Outside faces of the air part
                                  struct( 'g', lConvection.walls_int, ... % Convection coefficient specified by user
                                          'intersect', true), ...
                                  lOptions);
  lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

  lMod_Tmp = HT_Model_ConnectFaces(sprintf('mcWall_Over%d', i),       ...
                                  lMod_CylinderFaces.inside(i),       ... % Internal faces of the wall
                                  lMod_OverframeFaces.outside(i),     ... % Outside faces of the overframe
                                  struct( 'intersect', true),         ... % Convection coefficient specified by user
                                  lOptions);
  lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

  lMod_Tmp = HT_Model_ConnectFaces(sprintf('mcWall_AirUnderRoof%d', i),   ...
                                  lMod_CylinderFaces.inside(i),           ... % Internal faces of the wall
                                  lMod_AirUnderRoofFaces.outside(i),      ... % Outside faces of the overframe
                                  struct( 'intersect', true),             ... % Convection coefficient specified by user
                                  lOptions);
  lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);
endfor


% ========================================================================
% Build roof stone
% ========================================================================
[lMod_RoofStone, lMod_RoofStoneFaces] = HT_Model_ConductionCylinder3D("mRoof", ...
                                          struct( "radius", [0, lHiveParams.bodyRadius, lHiveParams.bodyRadius + lHiveParams.wallThickness, lHiveParams.stoneRadius], ...
                                                  "length", lHiveParams.stoneThickness, ...
                                                  "material", repmat(lHiveMat.roof, 3, 1), ...
                                                  "n", [lMesh.roofInner, lMesh.bodyRadius, lMesh.roofOuter, lMesh.circular, lMesh.roofHeight], ...
##                                                  "rGrid", lRoofrGrid, ...
                                                  "rGrid", {{ [], lMod_CylinderFaces.top, []}}, ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'hh', ...'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
##                                                  "axis", lHiveParams.globalAxis,               ... Loaded from base
##                                                  "globalPosition", lHiveParams.globalPosition, ... Loaded from base
                                                  "base", lMod_CylinderFaces.top, ...
                                                  "mergeTheta", true), ...
                                          lOptions);
##clear lRoofrGrid;

lModel = HT_Model_Merge(lModel, lMod_RoofStone, lOptions);

% Add external air convection coefficient to the roof sides
lMod_Tmp = HT_Model_Connect('mRoofSide_ExtAir', lAirExtNode,        ... % Node of outside air
                                  lMod_RoofStoneFaces.outside,        ... % Top face of the roof
                                  'g', lConvection.roof_ext,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

##% Add external air convection coefficient to the roof top
lMod_Tmp = HT_Model_Connect('mRoofTop_ExtAir', lAirExtNode,        ... % Node of outside air
                                  lMod_RoofStoneFaces.top,        ... % Top face of the roof
                                  'g', lConvection.roof_top,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add external air convection coefficient to the roof bottom
% First create a circular face based on roof bottom face. This object will be
% used to select a subpart of the roof bottom face
lBottomFaceSelect = HT_Face_CreateCircularMesh(lMod_RoofStoneFaces.bottom, ...
                      'radius', [lHiveParams.bodyRadius + lHiveParams.wallThickness, lHiveParams.stoneRadius], ...
                      'rGrid', int32(1));
lBottomFaceSelect = HT_Face_Intersect('mRoofBot_ExtAir', {lBottomFaceSelect, lMod_RoofStoneFaces.bottom}, ...
                      'mesh', true, ...
                      'coplanar', true, ...
                      'nodeClip', false); % Means "strict match"

% Add external air convection to the bottom external part of the roof
lMod_Tmp = HT_Model_Connect('mRoofBot_ExtAir', lAirExtNode,        ... % Node of outside air
                                  lBottomFaceSelect,        ... % Top face of the roof
                                  'g', lConvection.roof_top,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add thermal connection between hive body and roof
lMod_Tmp = HT_Model_ConnectFaces("mcBody_Roof", ...
                        lMod_RoofStoneFaces.bottom, ...
                        lMod_CylinderFaces.top, ...
                        [], ...
                        setfield(lOptions, 'strictMatch', true));
assert(numel(lMod_Tmp.nodes) == 2*lMesh.bodyRadius);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add thermal connection between underroof air layer and roof
lMod_Tmp = HT_Model_ConnectFaces("mcUnderRoof_Roof", ...
                        lMod_AirUnderRoofFaces.top, ...
                        lMod_RoofStoneFaces.bottom, ...
                        [], ...
                        setfield(lOptions, 'strictMatch', true));
assert(numel(lMod_Tmp.nodes) == 2*lMesh.innerRadius);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% ========================================================================
% Build the brick part on the ground
% ========================================================================
[lMod_BaseCylinder, lMod_BaseCylinderFaces] = HT_Model_ConductionCylinder3D("mBase", ...
                                          struct( "radius", [0, lHiveParams.bodyRadius + lHiveParams.wallThickness, lHiveParams.baseRadius], ...
                                                  "length", lHiveParams.baseThickness, ...
                                                  "material", repmat(lHiveMat.base, 2, 1), ...
                                                  "n", [lMesh.innerRadius + lMesh.bodyRadius, lMesh.baseOuter, lMesh.circular, lMesh.baseHeight], ...
                                                  "rGrid", {{ lMod_RoofStoneFaces.bottom, []}}, ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition - lHiveParams.baseThickness * lHiveParams.globalAxis(:,Z), ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_BaseCylinder, lOptions);

% Add thermal connection between hive body and brick base
lMod_Tmp = HT_Model_ConnectFaces("mcBody_Base", ...
                        lMod_BaseCylinderFaces.top, ...
                        lMod_CylinderFaces.bottom, ...
                        [], ...
                        setfield(lOptions, 'strictMatch', true));
assert(numel(lMod_Tmp.nodes) == 2*lMesh.bodyRadius);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add thermal connection between brick base and internal air
lMod_Tmp = HT_Model_ConnectFaces("mcAirBody_Base", ...
                        lMod_BaseCylinderFaces.top, ...
                        lMod_AirCylinderFaces.bottom, ...
                        [], ...
                        setfield(lOptions, 'strictMatch', true));
assert(numel(lMod_Tmp.nodes) == 2*lMesh.innerRadius);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add external air convection coefficient to the brick base
% First create a circular face based on roof bottom face. This object will be
% used to select a subpart of the roof bottom face
lBrickFaceSelect = HT_Face_CreateCircularMesh(lMod_BaseCylinderFaces.top, ...
                      'radius', [lHiveParams.bodyRadius + lHiveParams.wallThickness, lHiveParams.baseRadius], ...
                      'rGrid', int32(1));
lBrickFaceSelect = HT_Face_Intersect('baseTop_ExtAir', {lBrickFaceSelect, lMod_BaseCylinderFaces.top}, ...
                      'mesh', true, ...
                      'coplanar', true, ...
                      'nodeClip', false); % Means "strict match"

% Add external air convection to the brick base (top part)
lMod_Tmp = HT_Model_Connect('mcBaseTop_ExtAir', lAirExtNode,   ... % Node of outside air
                                  lBrickFaceSelect,            ... % Top face of the roof
                                  'g', lConvection.base_top,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add external air convection to the brick base (sides)
lMod_Tmp = HT_Model_Connect('mcBaseSides_ExtAir', lAirExtNode,    ... % Node of outside air
                                  lMod_BaseCylinderFaces.outside,   ... % Top face of the roof
                                  'g', lConvection.base_side,     ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% ========================================================================
% Build the ground
% ========================================================================
[lMod_GroundCylinder, lMod_GroundCylinderFaces] = HT_Model_ConductionCylinder3D("mGround", ...
                                          struct( "radius", [0, lHiveParams.baseRadius, lHiveParams.groundRadius], ...
                                                  "length", lHiveParams.groundThickness, ...
                                                  "material", repmat(lHiveMat.ground, 2, 1), ...
                                                  "n", [lMesh.innerRadius + lMesh.bodyRadius + lMesh.baseOuter, lMesh.groundOuter, lMesh.circular, lMesh.baseHeight], ...
                                                  "rGrid", {{ lMod_BaseCylinderFaces.bottom , struct('e1', lMesh.groundOuterRatio, 'e2', 0) }}, ...
                                                  "rGridType", 'ff', ...
                                                  "zGrid", [], ...
                                                  "zGridType", 'ff', ...
                                                  "T0", [], ...
                                                  "Rc", [], ...
                                                  "axis", lHiveParams.globalAxis, ...
                                                  "globalPosition", lHiveParams.globalPosition - (lHiveParams.baseThickness + lHiveParams.groundThickness) * lHiveParams.globalAxis(:,Z), ...
                                                  "mergeTheta", true), ...
                                          lOptions);

% Merge to the main model
lModel = HT_Model_Merge(lModel, lMod_GroundCylinder, lOptions);

% Add thermal connection between hive body and brick base
lMod_Tmp = HT_Model_ConnectFaces("mcGround_Base", ...
                        lMod_GroundCylinderFaces.top, ...
                        lMod_BaseCylinderFaces.bottom, ...
                        [], ...
                        setfield(lOptions, 'strictMatch', true));
assert(numel(lMod_Tmp.nodes) == 2*(lMesh.innerRadius+lMesh.bodyRadius+lMesh.baseOuter));
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

% Add external air convection coefficient to the ground base
% First create a circular face based on brick bottom face. This object will be
% used to select a subpart of the roof bottom face
lGroundExposedFace = HT_Face_CreateCircularMesh(lMod_GroundCylinderFaces.top, ...
                      'radius', [lHiveParams.baseRadius, lHiveParams.groundRadius], ...
                      'rGrid', int32(1));
lGroundExposedFace = HT_Face_Intersect('groundTop_ExtAir', {lGroundExposedFace, lMod_GroundCylinderFaces.top}, ...
                      'mesh', true, ...
                      'coplanar', true, ...
                      'nodeClip', false); % Means "strict match"

% Add external air convection to the brick base (top part)
lMod_Tmp = HT_Model_Connect('mcGroundTop_ExtAir', lAirExtNode,   ... % Node of outside air
                                  lGroundExposedFace,            ... % Top face of the roof
                                  'g', lConvection.ground,   ... % Convection coefficient specified by user
                                  lOptions);
lModel = HT_Model_Merge(lModel, lMod_Tmp, lOptions);

disp('==============================================');
disp(sprintf('Model built in %.2f s', lModel.timer.buildingTime));


